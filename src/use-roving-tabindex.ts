import React from "react";
import { ActionTypes, RovingTabIndexContext, State } from "./Provider";
import uniqueId from "lodash.uniqueid";

type ReturnType = [
  number,
  boolean,
  (event: React.KeyboardEvent<Element>) => void,
  () => void
];

enum TabDirection {
  Next,
  Previous
}

// domElementRef:
//   A React DOM element ref of the DOM element that is the focus target.
//   This must be the same DOM element for the lifecycle of the component.
// disabled:
//   Can be updated as appropriate to reflect the current enabled or disabled
//   state of the component.
// options:
//   Optional extra parameters for special situations:
//   id:
//     An optional ID that is the unique ID for the component.
//     If provided then it must be a non-empty string.
//     If not provided then one will be autogenerated.
//     This id value will be captured the first time that this hook
//     is called; it cannot be updated later.
//   rowIndex:
//     If the roving tabindex is being used with a grid then set this
//     parameter to the zero-based index of the row that the domElementRef
//     is currently part of. You can update this rowIndex value
//     as you like, for example if the grid shape can change dynamically,
//     although dynamic updating only occurs if
// The returned callbacks handleKeyDown and handleClick are stable.
export default function useRovingTabIndex(
  domElementRef: React.RefObject<Element>,
  disabled: boolean,
  options?: { id?: string; rowIndex?: number }
): ReturnType {
  const idRef = React.useRef(options?.id || null);

  function getId() {
    if (!idRef.current) {
      idRef.current = uniqueId("rti_");
    }
    return idRef.current;
  }

  const context = React.useContext(RovingTabIndexContext);

  // Registering and unregistering are tied to whether
  // the input is disabled or not.
  // React.useEffect(() => {
  //   if (disabled) {
  //     return;
  //   }
  //   context.dispatch({
  //     type: ActionTypes.REGISTER,
  //     payload: { id: getId(), domElementRef }
  //   });
  //   return (): void => {
  //     context.dispatch({
  //       type: ActionTypes.UNREGISTER,
  //       payload: { id: getId() }
  //     });
  //   };
  // }, [disabled]);

  React.useEffect(() => {
    const id = getId();
    context.dispatch({
      type: ActionTypes.REGISTER,
      payload: {
        id,
        domElementRef,
        rowIndex: options?.rowIndex || null,
        disabled
      }
    });
    return (): void => {
      context.dispatch({ type: ActionTypes.UNREGISTER, payload: { id } });
    };
  }, []);

  // Allow dynamic options to be updated.
  React.useEffect(() => {
    context.dispatch({
      type: ActionTypes.TAB_STOP_OPTIONS_UPDATED,
      payload: { id: getId(), rowIndex: options?.rowIndex || null, disabled }
    });
  }, [options?.rowIndex, disabled]);

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<Element>) => {
      if (disabled) {
        return;
      }
      const payload = { id: getId() };
      const direction = getDirection(event, context.state.direction);
      if (direction === TabDirection.Previous) {
        context.dispatch({
          type: ActionTypes.TAB_TO_PREVIOUS,
          payload
        });
        event.preventDefault();
      } else if (direction === TabDirection.Next) {
        context.dispatch({
          type: ActionTypes.TAB_TO_NEXT,
          payload
        });
        event.preventDefault();
      } else if (event.key === "Home") {
        context.dispatch({ type: ActionTypes.TAB_TO_FIRST });
        event.preventDefault();
      } else if (event.key === "End") {
        context.dispatch({ type: ActionTypes.TAB_TO_LAST });
        event.preventDefault();
      }
    },
    [context.state.direction]
  );

  const handleClick = React.useCallback(() => {
    if (disabled) {
      return;
    }
    context.dispatch({ type: ActionTypes.CLICKED, payload: { id: getId() } });
  }, []);

  const selected = getId() === context.state.selectedId;
  const tabIndex = selected ? 0 : -1;
  const focused = selected && context.state.lastActionOrigin !== null;
  return [tabIndex, focused, handleKeyDown, handleClick];
}

function getDirection(
  event: React.KeyboardEvent<Element>,
  direction: State["direction"]
): TabDirection | null {
  if (direction === "horizontal" || direction === "both") {
    if (event.key === "ArrowLeft") {
      return TabDirection.Previous;
    } else if (event.key === "ArrowRight") {
      return TabDirection.Next;
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (event.key === "ArrowUp") {
      return TabDirection.Previous;
    } else if (event.key === "ArrowDown") {
      return TabDirection.Next;
    }
  }
  return null;
}

import React from "react";
import { ActionTypes, RovingTabIndexContext } from "./Provider";
import uniqueId from "lodash.uniqueid";

type ReturnType = [
  number,
  boolean,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (event: React.KeyboardEvent<any>) => void,
  () => void
];

enum TabDirection {
  Next,
  Previous
}

// domElementRef:
//   - a React DOM element ref of the DOM element that is the focus target
//   - this must be the same DOM element for the lifecycle of the component
// disabled:
//   - can be updated as appropriate to reflect the current enabled or disabled
//     state of the component
// id:
//   - an optional ID that is the unique ID for the component
//   - if provided then it must be a non-empty string
//   - if not provided then one will be autogenerated
// The returned callbacks handleKeyDown and handleClick are stable.
export default function useRovingTabIndex(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  domElementRef: React.RefObject<any>,
  disabled: boolean,
  id?: string
): ReturnType {
  // This id is stable for the life of the component:
  const tabIndexId = React.useRef(id || uniqueId("roving-tabindex_"));
  const context = React.useContext(RovingTabIndexContext);

  // Registering and unregistering are tied to whether the input is disabled or not.
  // Context is not in the inputs because context.dispatch is stable.
  React.useLayoutEffect(() => {
    if (disabled) {
      return;
    }
    context.dispatch({
      type: ActionTypes.REGISTER,
      payload: { id: tabIndexId.current, domElementRef }
    });
    return (): void => {
      context.dispatch({
        type: ActionTypes.UNREGISTER,
        payload: { id: tabIndexId.current }
      });
    };
  }, [disabled]);

  const getDirection = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    event: React.KeyboardEvent<any>
  ): TabDirection | null => {
    if (
      context.state.direction === "horizontal" ||
      context.state.direction === "both"
    ) {
      if (event.key === "ArrowLeft") {
        return TabDirection.Previous;
      } else if (event.key === "ArrowRight") {
        return TabDirection.Next;
      }
    }
    if (
      context.state.direction === "vertical" ||
      context.state.direction === "both"
    ) {
      if (event.key === "ArrowUp") {
        return TabDirection.Previous;
      } else if (event.key === "ArrowDown") {
        return TabDirection.Next;
      }
    }
    return null;
  };

  const handleKeyDown = React.useCallback(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (event: React.KeyboardEvent<any>) => {
      const payload = { id: tabIndexId.current };
      const direction = getDirection(event);
      if (direction === TabDirection.Previous) {
        context.dispatch({
          type: ActionTypes.TAB_TO_PREVIOUS,
          payload
        });
        event.preventDefault();
      } else if (direction === TabDirection.Next) {
        context.dispatch({
          type: ActionTypes.TAB_TO_NEXT,
          payload
        });
        event.preventDefault();
      } else if (event.key === "Home") {
        context.dispatch({ type: ActionTypes.TAB_TO_FIRST });
        event.preventDefault();
      } else if (event.key === "End") {
        context.dispatch({ type: ActionTypes.TAB_TO_LAST });
        event.preventDefault();
      }
    },
    [context.state]
  );

  const handleClick = React.useCallback(() => {
    context.dispatch({
      type: ActionTypes.CLICKED,
      payload: { id: tabIndexId.current }
    });
  }, []);

  const selected = !disabled && tabIndexId.current === context.state.selectedId;
  const tabIndex = selected ? 0 : -1;
  const focused = selected && context.state.lastActionOrigin !== null;
  return [tabIndex, focused, handleKeyDown, handleClick];
}

import React from "react";
import {ActionTypes, RovingTabIndexContext} from "./Provider";
import uniqueId from "lodash.uniqueid";

type ReturnType = [
  number,
  boolean,
  (event: React.KeyboardEvent<any>) => void,
  () => void
];

enum TabDirection {
  Next,
  Previous
}

// domElementRef:
//   - a React DOM element ref of the DOM element that is the focus target
//   - this must be the same DOM element for the lifecycle of the component
// disabled:
//   - can be updated as appropriate to reflect the current enabled or disabled
//     state of the component
// id:
//   - an optional ID that is the unique ID for the component
//   - if provided then it must be a non-empty string
//   - if not provided then one will be autogenerated
// The returned callbacks handleKeyDown and handleClick are stable.
export default function useRovingTabIndex(
  domElementRef: React.RefObject<any>,
  disabled: boolean,
  id?: string
): ReturnType {
  // This id is stable for the life of the component:
  const tabIndexId = React.useRef(id || uniqueId("roving-tabindex_"));
  const context = React.useContext(RovingTabIndexContext);

  // Registering and unregistering are tied to whether the input is disabled or not.
  // Context is not in the inputs because context.dispatch is stable.
  React.useLayoutEffect(() => {
    if (disabled) {
      return;
    }
    context.dispatch({
      type: ActionTypes.REGISTER,
      payload: { id: tabIndexId.current, domElementRef }
    });
    return () => {
      context.dispatch({
        type: ActionTypes.UNREGISTER,
        payload: { id: tabIndexId.current }
      });
    };
  }, [disabled]);

  const getDirection = (event: React.KeyboardEvent<any>): TabDirection | null => {
    if (context.state.direction === "horizontal" || context.state.direction === "both") {
      if (event.key === "ArrowLeft") {
        return TabDirection.Previous;
      } else if (event.key === "ArrowRight") {
        return TabDirection.Next;
      }
    }
    if (context.state.direction === "vertical" || context.state.direction === "both") {
      if (event.key === "ArrowUp") {
        return TabDirection.Previous;
      } else if (event.key === "ArrowDown") {
        return TabDirection.Next;
      }
    }
    return null;
  };

  const handleKeyDown = React.useCallback((event: React.KeyboardEvent<any>) => {
    const payload = { id: tabIndexId.current };
    const direction = getDirection(event);
    if (direction === TabDirection.Previous) {
      context.dispatch({
        type: ActionTypes.TAB_TO_PREVIOUS,
        payload
      });
      event.preventDefault();
    } else if (direction === TabDirection.Next) {
      context.dispatch({
        type: ActionTypes.TAB_TO_NEXT,
        payload
      });
      event.preventDefault();
    } else if (event.key === "Home") {
      context.dispatch({ type: ActionTypes.TAB_TO_FIRST });
      event.preventDefault();
    } else if (event.key === "End") {
      context.dispatch({ type: ActionTypes.TAB_TO_LAST });
      event.preventDefault();
    }
  }, [context.state]);

  const handleClick = React.useCallback(() => {
    context.dispatch({
      type: ActionTypes.CLICKED,
      payload: { id: tabIndexId.current }
    });
  }, []);

  const selected = !disabled && tabIndexId.current === context.state.selectedId;
  const tabIndex = selected ? 0 : -1;
  const focused = selected && context.state.lastActionOrigin === "keyboard";
  return [tabIndex, focused, handleKeyDown, handleClick];
}
